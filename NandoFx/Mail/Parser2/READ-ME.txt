Suppose you are writing a program and it needs to receive e-mail messages and parse them, understanding e-mail headers, separating text content, HTML content and attachments, with the ability to decode all these parts and save them as files.

You would, of course, use the popular, open-source OpenPOP.NET library:
http://sourceforge.net/projects/hpop
That is what I did, because OpenPOP does all these things, it is all figured out.

The MIME format of e-mail messages is not simple, there are encodings for everything, so it takes a long time to develop a MIME library... but the OpenPOP guys really tackled it successfully.
http://en.wikipedia.org/wiki/MIME

The latest version of OpenPOP was 1.3, released on 2004-06-16. It was already one year and a half old, no improvements since then.

However, there was a little bug in the OpenPOP parser: it would not see some parts of a certain e-mail message. When you use free software, it is very important to collaborate with the community, so I decided I would fix this bug myself.

That was the beginning of a long story. The bug was terribly hard to see -- the code was not friendly to strangers, I ended up making LOTS of alterations, and something new was born. Since I was publishing it as a library, I just threw in reusable code for other purposes as well, and called it the NandoF library. The new MIME parser is in the NandoF.Mail.Parser2 namespace.

http://sourceforge.net/projects/nandof/

I don't like forking a successful project, but in this case, I can only hope the OpenPOP developers will like my alterations.

How is Parser2 different from the OpenPOP parser?


1) LOGS VERSUS WARNINGS
=======================

OpenPOP consumes all the exceptions it throws (and logs them). This forces you to use its logging scheme and to read its log. This means that, when the OpenPOP library behaves in a less-than-optimal way, it hides its faults (by consuming its own exceptions), so your application does not really know something went wrong. To mitigate this, many OpenPOP methods return boolean success codes, so the app at least knows if "it happened" or "it didn't happen". However, if something fails, the app does not know why.

Boolean success codes were very common in the past, but .NET exceptions are a much better way to handle this problem. Boolean success codes can be accidentally ignored by the programmer using the library, with serious consequences. Exceptions don't have this problem -- they demand correctness. Libraries should throw exceptions. Exceptions should not be consumed by code that cannot fix the problem. Exceptions may bubble up to the user interface. This is the layer that should catch the exception and do whatever you want to do with it.

My apps don't use logging and I don't think a library should force me to use it. Furthermore, logging is trivial to implement at a higher level if you want to.

In general, arguments to any method should be validated at the beginning, throwing meaningful exceptions when they are invalid:

	public void SaveAttachments(string path)  {
		if (path==null || path==string.Empty)  throw new
			ArgumentNullException("path");
		(...)

Parser2 keeps most of its exceptions during the parsing of a message, because that would mean, if anything went wrong, you would have NOTHING. Instead, the Message class has a property called Warnings. When something goes wrong, a warning is added to this property, but parsing continues, so whatever can be understood in the e-mail message still appears in the Message object. This is also better than a log file.

Parser2 has been tested with thousands of messages, many bugs were corrected and almost no warnings are appearing anymore.


2) CODE READABILITY
===================

I started reading OpenPOP in order to understand and solve a bug. I was annoyed by the lack of proper spacing in the code, in hundreds of lines such as...

  if(IsEncoding("8bit")&&_contentCharset!=null&_contentCharset!="")

There are almost no comments in the code and the documentation does not explain anything -- it simply repeats what methods name already say. This "documentation" is just annoying, taking lots of lines without explaining anything. Many method names have been improved. As much as possible, I am increasing code readability by fixing these things.

I like the "SharpDevelop C# Coding Style Guide 0.3", written by Mike Krueger:
http://www.icsharpcode.net/TechNotes/

By the way, there is a bug in the spaceless line I mentioned above. You need two &&, not one &. Shows the importance of spacing, otherwise who would see this? The line is in Attachment.DecodeAsText().


3) LITTLE BUGS
==============

Whenever you open a file with a StreamWriter object or a FileStream object, you should always put it in a "using" clause, like this:

	static public void SaveByteContentToFile(string file, byte[] bytContent) {
		if (File.Exists(file)) File.Delete(file);
		using (FileStream fs = File.Create(file)) {
			fs.Write(bytContent, 0, bytContent.Length);
		}
	}

The "using" clause ensures the file is closed even if an exception is thrown.

On another note, System.Path.Combine() should be used instead of manually concatenating directories, "\" and files.

I took advantage of opportunities to use more regular expressions, instead of looping algorythms.

I know I am criticizing OpenPOP somewhat, but I must say I adopted it instead of the alternatives because it was the best. Generally speaking, OpenPOP just works.


4) OBJECT ORIENTATION
=====================

The code was hard to understand because there weren't enough comments and because it was in a functional style. The "Message" class alone had 35 KB and 1000 lines... First thing I did was to split it in 2, so now Message contains a Headers object. This took hours to do but was worth it, for the sake of clarity.

MIME is object-oriented and so should the parser be. Through the use of the multipart type, MIME allows messages to have parts arranged in a tree structure where the leaf nodes are any non-multipart content type and the non-leaf nodes are any of a variety of multipart types. OpenPOP.MimeParser is unable to see all MIME parts in some messages.

In OpenPOP.MimeParser, a MIME part was imprecisely called Attachment. Then there was a NotAttachment property that distinguished a "real attachment" from a "simple MIME part". So it is better to call it MimePart.

Parser2 has an IMimePart interface with the following polymorphic subclasses:

IMimePart
 |
 -- Message  (represents an e-mail message, even inside another message)
 |
 -- MimePart (which is abstract)
      |
      -- MimePartMulti  (its purpose is to CONTAIN other MimeParts)
      |
      -- MimePartLeaf   (also abstract)
           |
           -- MimePartBinary  (represents a binary attachment)
           |
           -- MimePartText    (also abstract)
                |
                -- MimePartTextPlain  (represents plain text content)
                |
                -- MimePartTextHtml   (represents HTML  text content)

If not for this class hierarchy, a MIME part object would have too many properties, most of them would stay null most of the time and the behaviour would be confusingly scattered. (Objects consist of data and behaviour.)

The Factory pattern is used to generate MIME part objects as the parser sees them. This way, we can represent MIME trees of unlimited depth, thus solving the problem of some MIME parts not being parsed.

I think the most common layout for e-mail messages goes like this:

Message
 |
 -- multipart/mixed             (represented by a MimePartMulti)
      |
      -- multipart/alternative  (represented by a MimePartMulti)
      |    |
      |    -- text/html         (represented by a MimePartTextHtml)
      |    |
      |    -- text/plain        (represented by a MimePartTextPlain)
      |
      -- binary attachment(s)   (represented by a MimePartBinary)
      |
      -- Message (attached)     (represented by another Message)

To traverse this tree, user code typically uses recursion. But if you are only interested in very simple things, to make it really easy, Message has properties such as BodyText and BodyHtml, as well as a Leaves property that returns a simple array of all the MIME leaves (so you lose the tree perspective of the MimeTree property, but you can just foreach() and find what you want).

Another characteristic of Parser2 is that it relies only on a TextReader to parse the whole message. The interesting thing about TextReader is that it is an abstract class. The subclasses, StringReader and StreamReader, represent a string in memory and a file. So, by using a TextReader, we can read from memory OR from a file and not care a bit. The Message class has constructors that receive a TextReader, a string or a file name, and takes care of the rest.


5) WHAT HAS BEEN LOST
=====================

I have not implemented the MS TNEF format that OpenPOP supports. I have also never seen any message in that format... Nobody uses Microsoft Exchange anymore.
http://agamemnon.ucs.ed.ac.uk/faq/mstnef.html

I believe there are no other cons in Parser2.


THE FUTURE
==========

There exists a project of joining OpenPOP with OpenSMTP into a single e-mail library. It sounds great when I say it, but after having dealt with the MIME Parser, I don't know what the practical benefit would be. In practice, sending a message and receiving a message are totally different situations and very little code would be shared among them.

http://sourceforge.net/projects/mail-net/
(No code there yet.)

In any case, if this is ever done, I wish they would start from NandoF.Mail instead of OpenPOP.

Thanks,

Nando Florestan
http://sourceforge.net/projects/nandof/
