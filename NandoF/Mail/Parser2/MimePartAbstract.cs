#region  NandoF library -- Copyright 2005-2006 Nando Florestan
/*
This library is free software; you can redistribute it and/or modify
it under the terms of the Lesser GNU General Public License as published by
the Free Software Foundation; either version 2.1 of the License, or
(at your option) any later version.

This software is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program; if not, see http://www.gnu.org/copyleft/lesser.html

This file is based on OpenPOP.Net (2004/07) -- http://sf.net/projects/hpop/
                      Copyright 2003-2004 Hamid Qureshi and Unruled Boy
 */
#endregion

using ApplicationException        = System.ApplicationException;
using ArgumentNullException       = System.ArgumentNullException;
using System.Collections;
using System.Text.RegularExpressions;
using NandoF.Data;

namespace NandoF.Mail.Parser2
{
	public interface IMimePart {}
	
	
	/// <summary>Abstract base for the polymorphic subclasses that represent
	/// Mime parts of an e-mail message.</summary>
	public abstract class MimePart : IMimePart
	{
		protected ArrayList headers;
		
		public    string ContentType  {
			get  { return contentType; }
		}
		protected string contentType;
		
		protected string contentProps;
	}
	
	
	
	public abstract class MimePartLeaf : MimePart
	{
		public    string ContentRaw  {
			get  { return contentRaw; }
		}
		protected string contentRaw;
		
		public    string ContentTransferEncoding  {
			get  {
				if (contentTransferEncoding != null)  return contentTransferEncoding;
				// If we don't know it yet, find it
				foreach (NameVal header in this.headers)  {
					if (header.Name.ToUpper()=="CONTENT-TRANSFER-ENCODING")  {
						contentTransferEncoding = header.Val.ToLower();
						break;
					}
				}
				return contentTransferEncoding;
			}
		}
		protected string contentTransferEncoding;
	}
	
	
	
	public class MimePartMulti : MimePart
	{
		public   string    Boundary  {
			get  { return boundary; }
		}
		private  string    boundary;
		
		public   ArrayList Children  {
			get  { return children; }
		}
		private  ArrayList children = new ArrayList();
		
		/* Constructor */
		internal MimePartMulti(string contentType, string contentProps,
		                       ArrayList headers, Parser p)  {
			if (Text.IsNullOrEmpty(contentType))
				throw new ArgumentNullException("contentType");
			if (headers==null)  throw new ArgumentNullException("headers");
			if (p == null)      throw new ArgumentNullException("p");
			this.contentType  = contentType;
			this.contentProps = contentProps;
			this.headers      = headers;
			
			// Find boundary from part headers. Like:
			// Content-Type: multipart/alternative; boundary="----=_NextPart_000(...)"
			Match m = rxBoundary.Match(contentProps);
			// Every boundary line starts with -- plus the defined boundary
			if (m.Success)  boundary = "--" + m.Groups[1].Value;
			else throw new ApplicationException("No boundary in multipart header.");
			
			// If we are beginning to parse the body of a message,
			// the TextReader might be at a line that says:
			// "This is a multi-part message in MIME format."
			// This line is ignored. We just advance to the boundary line.
			string trash = p.ReadContentUntil(boundary);
//			while (true)  {
//				string line = p.rd.ReadLine();
//				++p.currentLine;
//				if (line==null)  {  // If end of file, add warning and give up
//					p.addWarning("Cannot find boundary", boundary);
//					return;
//				}
//				if (line==boundary) break;
//			}
			//Check if boundary is final already (this should never happen)
			if (p.BoundaryIsFinal)  {
				p.AddWarning("MultiPart without content", trash);
				return;
			}
			// Collect headers of sub-parts and produce them, until the
			// closing boundary (ends with "--") is found,
			// indicating the end of this multi-part.
			while (true)  {
				ArrayList subPartHeaders = p.readHeaders();
				// If there are no headers, it means
				// we have found the end of this MultiPart.
				if (subPartHeaders.Count==0)  break;
				// Produce the part and add it
				IMimePart newPart = p.ProducePart(subPartHeaders, boundary);
				// If newPart is null, a warning has been generated by ProducePart()
				if (newPart != null)  children.Add(newPart);
				// BUG FIXED: readHeaders() finding a boundary line when there is
				// a MimePartMulti (or a Message) inside another:
				// If the newPart is a leaf, we have already read a boundary line and
				// are at the point where we can loop and try to get next headers.
				// However, if newPart is a multipart or a message,
				// we have read ITS boundary and a blank line.
				// Now we need to advance to OUR boundary so we can
				// loop and try to get next headers.
				if (newPart is MimePartMulti || newPart is Message)  {
					trash = p.ReadContentUntil(boundary);
					if (trash != string.Empty && trash != "\r\n")
						p.AddWarning("Found content when skipping to boundary", trash);
				}
				// If the last boundary line ended with "--",
				// we can stop, otherwise, loop
				if (p.BoundaryIsFinal)  break;
			}
		}
		
		static private Regex rxBoundary = new
			Regex(@"boundary=\""?(?<boundary>[^\""]*)\""?$", RegexOptions.IgnoreCase);
	}
}
